---
title: Leetcode 72 编辑距离
date: 2023-10-17 19:35:00 +0900
categories: [Study notes, Leetcode]
tags: [leetcode, dynamic programming, string]
math: true
img_path: /assets/img/2023-10-17-Leetcode_72/
---

## 题目概述

[Leetcode 72](https://leetcode.com/problems/edit-distance/)

Given two strings `word1` and `word2`, return the **minimum number of operations** required to convert `word1` to `word2`.

You have the following three **operations** permitted on a word:
- Insert a character
- Delete a character
- Replace a character

<div style="text-align: center">
<img src="leetcode72_1.png"
        width="400"
        height="320"/>
</div>

**Constraints:**
- `0 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of lowercase English letters.

## 思路
### 初步尝试
根据题意，我们需要对`word1`这个字符串用尽可能少的操作（添加、删除或替换字符）数，使之与字符串`word2`匹配。可以设想到当两个字符串相当长时，直接求解会十分困难，由此自然地会去思考能否把这个问题分解成多个子问题，此时已经预感到这道题或许可以使用动态规划来解决。那么既然要使用动态规划的话，我们需要定义一个合适的状态，也就是子问题的形态。

不妨这样设：`dp[i][j]`表示`word1`中索引值 $[0, i]$, `word2`中索引值 $[0, j]$ 的这两个子串所对应的该问题的解。（注意是闭区间）

接下来思考状态间是如何转移的。我们举一个例子来具体地观察一下，假设两个字符串如下所示：

$$
\begin{aligned}
    \bold{
        i \quad n \quad t \quad e \quad n \quad t \quad i \quad o \quad n
    }
    \\
    \bold{
        e \quad x \quad e \quad c \quad u \quad t \quad i \quad o \quad n
    }
\end{aligned}
$$

在这里有一个问题需要明确： 是否需要对不同相对位置的 $i$ 与 $j$ 进行分类讨论？在最初的思考过程中我并没有一下子弄清楚这个问题，所以不妨先实际操作一下试试看。假设现在 $i = 5$，$j = 5$：

$$
\begin{aligned}
    \bold{
        {\color{royalblue}{i \quad n \quad t \quad e \quad n}} \quad {\color{red}{t}} \quad i \quad o \quad n
    }
    \\
    \bold{
        {\color{royalblue}{e \quad x \quad e \quad c \quad u}} \quad {\color{red}{t}} \quad i \quad o \quad n
    }
\end{aligned}
$$



## 代码实现
1. 在 $n > 4$ 时，尽可能多地分离出3
   
    **Time complexity: O(n)**

    **Space complexity: O(1)**

    ```python
    class Solution:
        def integerBreak(self, n: int) -> int:
            if n <= 3:
                return n - 1

            ans = 1
            while n > 4:
                ans *= 3
                n -= 3

            return ans * n
    ```

    <div style="text-align: left">
    <img src="leetcode72_1.png"
            width="800"
            height="640"/>
    </div>

2. 优化, 根据 $n$ 的值直接可以计算出分离出来的3的个数, 按照其除以3的余数分类讨论即可

    **Time complexity: O(logn)**

    **Space complexity: O(1)**

    ```python
    class Solution:
        def integerBreak(self, n: int) -> int:
            if n <= 3:
                return n - 1

            if n % 3 == 0:
                return 3 ** (n // 3)
            elif n % 3 == 1:
                return 3 ** ((n - 4) // 3) * 4
            else:
                return 3 ** ((n - 2) // 3) * 2
                
    ```

    <div style="text-align: left">
    <img src="leetcode72_1.png"
            width="800"
            height="640"/>
    </div>

    注： 乘方运算的时间复杂度为 **O(logn)**