---
title: Leetcode 72 编辑距离
date: 2023-10-17 19:35:00 +0900
categories: [Study notes, Leetcode]
tags: [leetcode, dynamic programming, string]
math: true
img_path: /assets/img/2023-10-17-Leetcode_72/
---

## 题目概述

[Leetcode 72](https://leetcode.com/problems/edit-distance/)

Given two strings `word1` and `word2`, return the **minimum number of operations** required to convert `word1` to `word2`.

You have the following three **operations** permitted on a word:
- Insert a character
- Delete a character
- Replace a character

<div style="text-align: center">
<img src="leetcode72_1.png"
        width="400"
        height="320"/>
</div>

**Constraints:**
- `0 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of lowercase English letters.

## 思路
### 初步尝试
根据题意，我们需要对`word1`这个字符串用尽可能少的操作（添加、删除或替换字符）数（也即**编辑距离**），使之与字符串`word2`匹配。可以设想到当两个字符串相当长时，直接求解会十分困难，由此自然地会去思考能否把这个问题分解成多个子问题，此时已经预感到这道题或许可以使用动态规划来解决。那么既然要使用动态规划的话，我们需要定义一个合适的状态，也就是子问题的形态。

不妨这样设：`dp[i][j]`表示`word1`中索引值 $[0, i]$, `word2`中索引值 $[0, j]$ 的这两个子串所对应的**编辑距离**。（注意是闭区间）

接下来思考状态间是如何转移的。我们举一个例子来具体地观察一下，假设两个字符串如下所示：

$$
\begin{aligned}
    i \quad n \quad t \quad e \quad n \quad t \quad i \quad o \quad n
    \\
    e \quad x \quad e \quad c \quad u \quad t \quad i \quad o \quad n
\end{aligned}
$$

在这里有一个问题需要明确： 是否需要对不同相对位置的 $i$ 与 $j$ 进行分类讨论？在最初的思考过程中我并没有一下子弄清楚这个问题，所以不妨先实际操作一下试试看。

- 令 $i = 5$，$j = 5$：

    $$
    \begin{aligned}
        {\color{royalblue}{i \quad n \quad t \quad e \quad n}} \quad {\color{red}{t}} \quad i \quad o \quad n
        \\
        {\color{royalblue}{e \quad x \quad e \quad c \quad u}} \quad {\color{red}{t}} \quad i \quad o \quad n
    \end{aligned}
    $$

此时两个子串的最后一位相同，无需进行额外的操作。那么这两个子串的编辑距离与各自除去最后一位的子串的编辑距离相等，即`dp[i][j] = dp[i-1][j-1]`

- 令 $i = 4$，$j = 4$：

    $$
    \begin{aligned}
        {\color{royalblue}{i \quad n \quad t \quad e}} \quad {\color{red}{n}} \quad t \quad i \quad o \quad n
        \\
        {\color{royalblue}{e \quad x \quad e \quad c}} \quad {\color{red}{u}} \quad t \quad i \quad o \quad n
    \end{aligned}
    $$

此时两个子串的最后一位不同，那么就需要考虑进行三种操作后的结果是什么。
- **替换：** 将最后一位替换成一样的字符之后，情况就与上文中第一种相同了，答案取决于最后一位之前的子串的编辑距离，所以结果为: `dp[i][j] = 1 + dp[i-1][j-1]`
- **删除：** 将最后一位删除的话，则需要匹配的子串变为下方所示的蓝色部分，所以结果为：`dp[i][j] = 1 + dp[i-1][j]`

    $$
    \begin{aligned}
        & {\color{royalblue}{i \quad n \quad t \quad e}} \quad {\color{red}{\bcancel{n}}} \quad t \quad i \quad o \quad n
        \\
        & {\color{royalblue}{e \quad x \quad e \quad c \quad u}} \quad t \quad i \quad o \quad n
    \end{aligned}
    $$

- **添加：** 添加一个字符。首先为了使编辑距离最短，这里添加的字符一定是与`word2[j]`匹配的。其次得注意添加的位置有两种选择，一种是添加到`word1[i]`的左边，另一种则是添加到`word1[i]`的右边。此时需要考虑遍历字符串的顺序，`word[i]`的下一位是`word[i+1]`，而如果将新字符添加到左边会导致`word[i]`在并没有被匹配的情况下就被略过了。过程如下：

    $$
    \begin{aligned}
        & {\color{royalblue}{i \quad n \quad t \quad e \quad u}} \quad {\color{green}{n}} \quad {\color{red}{t}} \quad i \quad o \quad n
        \\
        & {\color{royalblue}{e \quad x \quad e \quad c \quad u}} \quad {\color{red}{t}} \quad i \quad o \quad n
    \end{aligned}
    $$

    故添加到左边不可行。如果是添加到右边，情况如下：

    $$
    \begin{aligned}
        & {\color{royalblue}{i \quad n \quad t \quad e \quad n}} \quad {\color{red}{u}} \quad t \quad i \quad o \quad n
        \\
        & {\color{royalblue}{e \quad x \quad e \quad c}} \quad {\color{red}{u}} \quad t \quad i \quad o \quad n
    \end{aligned}
    $$

    可以看到子串末尾已被匹配，而编辑距离取决于上方的蓝色部分。结果为：`dp[i][j] = 1 + dp[i][j-1]`

那么回到一开始提出的问题：**是否需要对不同相对位置的** $i$ **与** $j$ **进行分类讨论？** 

**答案是不用的。** 从上述的几种状态中其实可以发现无论两个子串结尾的索引位置是否相同，我们都可以使用同样的思考方式来求解编辑距离，也就是说这些子结构之间都是等效的。否则上述的推导式从一开始就将不成立，因为那样的话状态就只有在 $i = j$ 的时候才能被定义。

至此，三种操作方式对应的状态转移方程就都推导出来了，而对于状态`dp[i][j]`，最终的结果应该取三种操作中编辑距离的最小值。用代码总结如下：

```python
if word1[i] == word2[j]:
    dp[i][j] = dp[i-1][j-1]
else:
    # min(replace, delete, insert)
    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
```

但问题到这里并未被最终解决，因为可以观察到状态转移方程中有`i-1`, `j-1`的存在，故 $i = 0$, $j = 0$ 的情况还需单独讨论。

## 代码实现
